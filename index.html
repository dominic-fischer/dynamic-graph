<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>D3 Time-Filtered Dynamic Graph</title>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      #controls {
        padding: 10px;
        background: #d3d0d0;
        display: flex;
        align-items: center;
        gap: 12px;
      }
      label {
        font-size: 14px;
      }
      input[type="range"] {
        flex: 1;
      }
      #dynamic-graph-container {
        background-color: rgb(36, 41, 41);
        flex: 1;
        position: relative; /* helps tooltip positioning */
      }
      /* keep only opacity here; color comes from D3 */
      #dynamic-graph-container svg line {
        stroke-opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <label for="time-slider">Time: <span id="time-value"></span></label>
      <input
        type="range"
        id="time-slider"
        min="1520"
        max="1575"
        step="1"
        value="1520"
      />

      <label for="topn-slider">Top N: <span id="topn-value">All</span></label>
      <input
        type="range"
        id="topn-slider"
        min="0"
        max="50"
        step="5"
        value="50"
      />

      <button id="play-toggle" type="button">▶ Play</button>
      <style>
        #play-toggle { padding: 6px 10px; cursor: pointer; }

        :root {
          --controls-h: 0px;
          --sidebar-w: 340px;
        }

        /* Overlay panel */
        #sidebar {
          position: fixed;
          left: 0;
          top: var(--controls-h);          /* starts below the sliders */
          width: var(--sidebar-w);
          height: calc(100vh - var(--controls-h));

          background: rgba(15, 15, 18, 0.96);
          backdrop-filter: blur(6px);

          color: #eee;
          border-right: 1px solid rgba(255,255,255,0.12);
          overflow: auto;

          transform: translateX(-105%);
          transition: transform 240ms cubic-bezier(.2,.8,.2,1);

          z-index: 50;                     /* above SVG */
          padding: 14px 14px 20px;
          box-sizing: border-box;

          box-shadow: 6px 0 30px rgba(0,0,0,.45);
        }

        #sidebar.open {
          transform: translateX(0);
        }


        #sidebar-close {
          position: sticky;
          top: 0;
          float: right;
          margin: 0 0 8px 8px;
          padding: 6px 10px;
          cursor: pointer;
        }

        #sidebar-content h2 {
          margin: 0 0 6px;
          font-size: 18px;
        }

        #sidebar-content .meta {
          opacity: 0.85;
          font-size: 13px;
          margin-bottom: 10px;
        }

        #sidebar-content img.thumb {
          display: block;
          width: 100%;
          height: auto;
          border-radius: 8px;
          margin: 10px 0;
        }

        #sidebar-content a {
          color: #8ab4ff;
          text-decoration: none;
        }
        #sidebar-content a:hover {
          text-decoration: underline;
        }

        #sidebar-backdrop {
          position: fixed;
          inset: 0;
          background: rgba(0,0,0,.35);
          opacity: 0;
          pointer-events: none;
          transition: opacity 200ms ease;
          z-index: 40;
        }

        #sidebar.open + #sidebar-backdrop {
          opacity: 1;
          pointer-events: auto;
        }
      </style>

      <label style="display:flex; align-items:center; gap:6px;">
        <input type="checkbox" id="correspondence-toggle" checked />
        Correspondence links
      </label>
    </div>

    <div id="sidebar" aria-hidden="true">
      <button id="sidebar-close" type="button" title="Close">✕</button>
      <div id="sidebar-content"></div>
    </div>
    <div id="sidebar-backdrop"></div>

    <div id="dynamic-graph-container"></div>

    <script type="module">
      import * as d3 from "d3";
      import DynamicGraph from "./src/d3-dynamic-graph";

      const BASE = import.meta.env.BASE_URL; // "/" in dev, "/dynamic-graph/" on GH Pages

      const [nodesData, linksData, correspondenceData, personInfo] = await Promise.all([
        fetch(`${BASE}person_nodes.json`).then((r) => r.json()),
        fetch(`${BASE}yearly_links.json`).then((r) => r.json()),
        fetch(`${BASE}yearly_correspondence_links.json`).then((r) => r.json()),
        fetch(`${BASE}person_gnd_wiki.json`).then((r) => r.json()), // <-- rename to your actual file
      ]);

      const nodes = nodesData;
      const links = linksData.map((l) => ({ ...l, linkType: "normal" }));
      const correspondenceLinks = correspondenceData.map((l) => ({
        ...l,
        linkType: "correspondence",
      }));

      // Select container and measure bounds
      const container = d3.select("#dynamic-graph-container");
      const controlsEl = document.getElementById("controls");

      const sidebarEl = document.getElementById("sidebar");
      const sidebarContentEl = document.getElementById("sidebar-content");
      const sidebarCloseBtn = document.getElementById("sidebar-close");

      sidebarEl.addEventListener("pointerdown", e => e.stopPropagation());
      sidebarEl.addEventListener("click", e => e.stopPropagation());
      document.getElementById("sidebar-backdrop")
        .addEventListener("click", closeSidebar);

      function setControlsHeightVar() {
        const h = getTopOffset();
        document.documentElement.style.setProperty("--controls-h", `${h}px`);
      }

      function openSidebarForNode(node) {
        // Your nodes seem to have ids like "P1". Use node.id as key.
        const info = personInfo?.[node.id] || null;

        const wiki = info?.wiki || null;
        const gnd = info?.gnd || null;

        const ws = info?.wiki_summary || null;
        const title = ws?.title || node.name || node.id;
        const desc = ws?.description || "";
        const summary = ws?.summary || "";
        const thumb = ws?.thumbnail || null;

        sidebarContentEl.innerHTML = `
          <h2>${escapeHtml(title)}</h2>
          ${desc ? `<div class="meta">${escapeHtml(desc)}</div>` : ""}
          ${thumb ? `<img class="thumb" src="${thumb}" alt="${escapeHtml(title)}" />` : ""}
          ${summary ? `<p>${escapeHtml(summary)}</p>` : `<p><em>No wiki summary available.</em></p>`}

          <hr style="border:0;border-top:1px solid rgba(255,255,255,0.12);margin:12px 0" />

          <div>
            ${wiki ? `<div>Wiki: <a href="${wiki}" target="_blank" rel="noopener">open</a></div>` : `<div>Wiki: <em>none</em></div>`}
            ${gnd ? `<div>GND: <a href="${gnd}" target="_blank" rel="noopener">open</a></div>` : `<div>GND: <em>none</em></div>`}
          </div>
        `;

        sidebarEl.classList.add("open");
        sidebarEl.setAttribute("aria-hidden", "false");
      }

      function closeSidebar() {
        sidebarEl.classList.remove("open");
        sidebarEl.setAttribute("aria-hidden", "true");
      }

      sidebarCloseBtn.addEventListener("click", closeSidebar);

      // Minimal escaping for injected HTML
      function escapeHtml(str) {
        return String(str).replace(/[&<>"']/g, (m) => ({
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;",
        }[m]));
      }


      function getSize() {
        const { width, height } = container.node().getBoundingClientRect();
        return { width, height };
      }
      function getTopOffset() {
        // height of the slider/toggle bar (the region nodes/labels must not enter)
        return controlsEl.getBoundingClientRect().height;
      }

      let { width, height } = getSize();

      // pass topOffset so the simulation can keep nodes/labels out from under the controls
      const vis = DynamicGraph(container, d3, {
        width,
        height,
        topOffset: getTopOffset(),
        onNodeClick: (node) => openSidebarForNode(node),
        onBackgroundClick: () => closeSidebar(), // only if you added svg.on("click"...)
      }).nodeRadius((d) => d.radius);

      function getNodeColorAtTime(node, t) {
        if (Array.isArray(node.colorSchedule)) {
          const entry = node.colorSchedule.find(
            ([color, start, end]) => start <= t && end >= t
          );
          return entry ? entry[0] : null;
        }
        return node.color;
      }

      function filterLinks(linkArray, activeIds, t) {
        return linkArray
          .filter((l) => l.start <= t && l.end >= t)
          .filter((l) => activeIds.has(l.sourceId) && activeIds.has(l.targetId));
      }

      function filterByTime(t, topN = null) {
        // keep topOffset up-to-date (e.g., if controls wrap to 2 lines)
        vis.pubVar({ year: t, topOffset: getTopOffset() });

        let filteredNodes = nodes.filter((n) => n.start <= t && n.end >= t);

        if (topN !== null && topN > 0 && topN < filteredNodes.length) {
          filteredNodes = filteredNodes
            .slice()
            .sort((a, b) => b.radius - a.radius)
            .slice(0, topN);
        }

        filteredNodes.forEach((node) => {
          node.color = getNodeColorAtTime(node, t);
        });

        const activeIds = new Set(filteredNodes.map((n) => n.id));
        const includeCorr = corrToggle.property("checked");

        const activeLinks = [
          ...filterLinks(links, activeIds, t),
          ...(includeCorr ? filterLinks(correspondenceLinks, activeIds, t) : []),
        ];

        vis.updateVis(filteredNodes, activeLinks);
      }

      // Slider
      const timeSlider = d3.select("#time-slider");
      const timeLabel = d3.select("#time-value");
      const corrToggle = d3.select("#correspondence-toggle");
      const topnSlider = d3.select("#topn-slider");
      const topnLabel = d3.select("#topn-value");

      function updateFromSliders() {
        const t = +timeSlider.property("value");
        const n = +topnSlider.property("value");
        timeLabel.text(t);
        topnLabel.text(n >= nodes.length ? "All" : n);
        filterByTime(t, n);
      }

      timeSlider.on("input", updateFromSliders);
      topnSlider.on("input", updateFromSliders);
      corrToggle.on("change", updateFromSliders);

      // --- Play / Pause ---
      const playBtn = document.getElementById("play-toggle");

      let isPlaying = false;
      let playTimer = null;

      // tune these:
      const PLAY_INTERVAL_MS = 3000; // how fast it steps (lower = faster)
      const PLAY_STEP = 1;          // years per step

      function setPlaying(next) {
        isPlaying = next;

        if (playTimer) {
          clearInterval(playTimer);
          playTimer = null;
        }

        playBtn.textContent = isPlaying ? "⏸ Pause" : "▶ Play";

        if (!isPlaying) return;

        playTimer = setInterval(() => {
          const min = +timeSlider.attr("min");
          const max = +timeSlider.attr("max");
          let t = +timeSlider.property("value");

          t += PLAY_STEP;

          // loop back to start when reaching the end
          if (t > max) t = min;

          timeSlider.property("value", t);
          updateFromSliders();
        }, PLAY_INTERVAL_MS);
      }

      playBtn.addEventListener("click", () => setPlaying(!isPlaying));

      // (nice UX) if the user manually drags the slider, pause playback
      timeSlider.on("input", () => {
        if (isPlaying) setPlaying(false);
        updateFromSliders();
      });

      setControlsHeightVar();

      window.addEventListener("resize", () => {
        setControlsHeightVar();
        const size = getSize();
        vis.pubVar({ width: size.width, height: size.height, topOffset: getTopOffset() });
        filterByTime(+timeSlider.property("value"), +topnSlider.property("value"));
      });

      // initial render
      updateFromSliders();
    </script>
  </body>
</html>