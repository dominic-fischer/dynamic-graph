<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>D3 Time-Filtered Dynamic Graph</title>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      #controls {
        padding: 10px;
        background: #d3d0d0;
        display: flex;
        align-items: center;
        gap: 12px;
      }
      label {
        font-size: 14px;
      }
      input[type="range"] {
        flex: 1;
      }
      #dynamic-graph-container {
        background-color: rgb(36, 41, 41);
        flex: 1;
      }
      /* Style links with a custom color */
      #dynamic-graph-container svg line {
        stroke: #e3ebef;
        stroke-opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <label for="time-slider">Time: <span id="time-value"></span></label>
      <input
        type="range"
        id="time-slider"
        min="1520"
        max="1575"
        step="1"
        value="1520"
      />


      <label for="topn-slider">Top N: <span id="topn-value">All</span></label>
      <input
        type="range"
        id="topn-slider"
        min="0"
        max="50"
        step="5"
        value="50"
      />
    </div>
    <div id="dynamic-graph-container"></div>

    <script type="module">
      import * as d3 from "d3";
      import DynamicGraph from "./src/d3-dynamic-graph";

      const BASE = import.meta.env.BASE_URL; // "/" in dev, "/dynamic-graph/" on GH Pages

      const [nodesData, linksData] = await Promise.all([
        fetch(`${BASE}person_nodes.json`).then(r => r.json()),
        fetch(`${BASE}yearly_links.json`).then(r => r.json()),
      ]);

      // ✅ define what the rest of your code uses
      const nodes = nodesData;
      const links = linksData;

      // Select container and measure bounds
      const container = d3.select("#dynamic-graph-container");
      function getSize() {
        const { width, height } = container.node().getBoundingClientRect();
        return { width, height };
      }

      let { width, height } = getSize();
      const vis = DynamicGraph(container, d3, { width, height })
        .nodeRadius((d) => d.radius);

      function getNodeColorAtTime(node, t) {
        if (Array.isArray(node.colorSchedule)) {
          const entry = node.colorSchedule.find(
            ([color, start, end]) => start <= t && end >= t
          );
          return entry ? entry[0] : null;
        }
        return node.color;
      }

      function filterByTime(t, topN = null) {
        vis.pubVar({ year: t });

        let filteredNodes = nodes.filter((n) => n.start <= t && n.end >= t);

        if (topN !== null && topN > 0 && topN < filteredNodes.length) {
          filteredNodes = filteredNodes
            .slice()
            .sort((a, b) => b.radius - a.radius)
            .slice(0, topN);
        }

        filteredNodes.forEach((node) => {
          node.color = getNodeColorAtTime(node, t);
        });

        const activeIds = new Set(filteredNodes.map((n) => n.id));
        const activeLinks = links
          .filter((l) => l.start <= t && l.end >= t)
          .filter((l) => activeIds.has(l.sourceId) && activeIds.has(l.targetId));

        vis.updateVis(filteredNodes, activeLinks);
      }

      // Slider
      const timeSlider = d3.select("#time-slider");
      const timeLabel = d3.select("#time-value");

      const topnSlider = d3.select("#topn-slider");
      const topnLabel = d3.select("#topn-value");

      function updateFromSliders() {
        const t = +timeSlider.property("value");
        const n = +topnSlider.property("value");
        timeLabel.text(t);
        topnLabel.text(n >= nodes.length ? "All" : n);
        filterByTime(t, n);
      }

      timeSlider.on("input", updateFromSliders);
      topnSlider.on("input", updateFromSliders);

      // ✅ fix resize handler: use timeSlider, not slider
      window.addEventListener("resize", () => {
        filterByTime(+timeSlider.property("value"), +topnSlider.property("value"));
      });

      // ✅ initial render (assumes your HTML slider default is sane)
      updateFromSliders();
</script>

  </body>
</html>
