<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>D3 Time-Filtered Dynamic Graph</title>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      #controls {
        padding: 10px;
        background: #d3d0d0;
        display: flex;
        align-items: center;
        gap: 12px;
      }
      label {
        font-size: 14px;
      }
      input[type="range"] {
        flex: 1;
      }
      #dynamic-graph-container {
        background-color: rgb(36, 41, 41);
        flex: 1;
      }
      /* Style links with a custom color */
      #dynamic-graph-container svg line {
        stroke: #e3ebef;
        stroke-opacity: 0.8;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <label for="time-slider">Time: <span id="time-value"></span></label>
      <input
        type="range"
        id="time-slider"
        min="1500"
        max="1600"
        step="1"
        value="0"
      />

      <label for="topn-slider">Top N: <span id="topn-value">All</span></label>
      <input
        type="range"
        id="topn-slider"
        min="0"
        max="50"
        step="5"
        value="50"
      />
    </div>
    <div id="dynamic-graph-container"></div>

    <script type="module">
      import * as d3 from "d3";
      import DynamicGraph from "./src/d3-dynamic-graph";
      import nodesData from "./person_nodes.json" assert { type: "json" };
      import linksData from "./yearly_links.json" assert { type: "json" };

      // Data with many nodes and time ranges
      const nodes = nodesData;
      const links = linksData;

      // Select container and measure bounds
      const container = d3.select("#dynamic-graph-container");
      function getSize() {
        const { width, height } = container.node().getBoundingClientRect();
        return { width, height };
      }

      // Create graph with dynamic size
      let { width, height } = getSize();
      const vis = DynamicGraph(container, d3, { width, height })
        .nodeRadius((d) => d.radius)
        .tooltipInnerHTML((d) => d.name);

      // Re-render on resize
      window.addEventListener("resize", () => {
        const size = getSize();
        //vis.resize(size.width, size.height);
        // reapply current filter
        filterByTime(+slider.property("value"));
      });

      function getNodeColorAtTime(node, t) {
        if (Array.isArray(node.colorSchedule)) {
          const entry = node.colorSchedule.find(
            ([color, start, end]) => start <= t && end >= t
          );
          return entry ? entry[0] : null;
        }
        return node.color; // fallback if no schedule
      }

      // Time filter logic
      function filterByTime(t, topN = null) {
        let filteredNodes = nodes.filter((n) => n.start <= t && n.end >= t);

        if (topN !== null && topN > 0 && topN < filteredNodes.length) {
          // Sort descending by radius and take top N
          filteredNodes = filteredNodes
            .slice()
            .sort((a, b) => b.radius - a.radius)
            .slice(0, topN);
        }

        // Assign dynamic color
        filteredNodes.forEach((node) => {
          node.color = getNodeColorAtTime(node, t);
        });

        const activeIds = new Set(filteredNodes.map((n) => n.id));
        const activeLinks = links
          .filter((l) => l.start <= t && l.end >= t)
          .filter(
            (l) => activeIds.has(l.sourceId) && activeIds.has(l.targetId)
          );

        vis.updateVis(filteredNodes, activeLinks);
      }

      // Slider
      const timeSlider = d3.select("#time-slider");
      const timeLabel = d3.select("#time-value");

      const topnSlider = d3.select("#topn-slider");
      const topnLabel = d3.select("#topn-value");

      function updateFromSliders() {
        const t = +timeSlider.property("value");
        const n = +topnSlider.property("value");
        timeLabel.text(t);
        topnLabel.text(n >= nodes.length ? "All" : n);
        filterByTime(t, n);
      }

      timeSlider.on("input", updateFromSliders);
      topnSlider.on("input", updateFromSliders);

      // Initial render
      timeLabel.text(timeSlider.property("value"));
      filterByTime(+timeSlider.property("value"));
    </script>
  </body>
</html>
